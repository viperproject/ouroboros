
function DISJOINT(g1: Set[Ref], g2:Set[Ref]): Bool
{
    (forall n: Ref :: { (n in g1),(n in g2) } (n in g1) ==> !((n in g2))) && (forall n: Ref :: { (n in g1),(n in g2) } (n in g2) ==> !((n in g1)))
}

function NoNullInGraph(g0:Set[Ref]): Bool
{
    !(null in g0)
}

function CLOSED(g: Set[Ref]): Bool
    requires (forall n: Ref :: { n.$field$ } (n in g) ==> acc(n.$field$, 1 / 2))
{
    (forall n: Ref :: { (n.$field$ in g) } { (n in g),n.$field$ } (n in g) && n.$field$ != null ==> (n.$field$ in g))
}

function apply_TCFraming(g0:Set[Ref], g1:Set[Ref]): Bool
    //requires GRAPH(g0) && GRAPH(g1)
    //requires forall n:Ref :: {n.l} n in g0 ==> acc(n.l)
    //requires forall n:Ref :: {n.r} n in g0 ==> acc(n.r)
    //requires forall n:Ref :: {n.l} n in g1 ==> acc(n.l)
    //requires forall n:Ref :: {n.r} n in g1 ==> acc(n.r)

    //requires disjoint_sets(g0,g1) //Not needed at the moment, as input graphs are always disjoint, and otherwise we use setminus
    requires (forall n:Ref :: { n in g0, n in g1 } n in g0 ==> !(n in g1))
    requires (forall n:Ref :: { n in g0, n in g1 } n in g1 ==> !(n in g0))

    // needed for triggering
    ensures g0 union g1 == g1 union g0

    ensures forall u:Ref, v:Ref :: { exists_path($$(g0),u,v) }{ exists_path($$(g0 union g1),u,v) } u in g0 && v in g0 && exists_path($$(g0),u,v) ==> exists_path($$(g0 union g1),u,v)
    ensures forall u:Ref, v:Ref :: { exists_path($$(g1),u,v) }{ exists_path($$(g1 union g0),u,v) } u in g1 && v in g1 && exists_path($$(g1),u,v) ==> exists_path($$(g1 union g0),u,v)

    ensures forall u:Ref, v:Ref :: { exists_path($$(g0),u,v)}{ exists_path($$(g0 union g1),u,v) } u in g0 && v in g0 && !exists_path($$(g0 union g1),u,v) ==> !exists_path($$(g0),u,v)
    ensures forall u:Ref, v:Ref :: { exists_path($$(g1),u,v) }{ exists_path($$(g1 union g0),u,v) } u in g1 && v in g1 && !exists_path($$(g1 union g0),u,v) ==> !exists_path($$(g1),u,v)


    //probably wrong
    //ensures forall u:Ref, v:Ref :: { exists_path($$(g0),u,v) }{ exists_path($$(g0 union g1),u,v) } u in g0 && v in g0 && !exists_path($$(g0),u,v) ==> !exists_path($$(g0 union g1),u,v)
    //ensures forall u:Ref, v:Ref :: { exists_path($$(g1),u,v) }{ exists_path($$(g0 union g1),u,v) } u in g1 && v in g1 && !exists_path($$(g1),u,v) ==> !exists_path($$(g1 union g0),u,v)

method new_node() returns (node: Ref)

method create_node(u: Set[Ref]) returns (node: Ref)
{
    var lhs_node: Ref //when inlining, remove lhs_node declaration, and replace lhs_node occurences by name of node
    var fresh_x: Ref
    var singleton_graph: Set[Ref] //fresh_x and singleton_graph should be added on top of the method
    assume !(fresh_x in u)
    assume fresh_x in singleton_graph && forall n: Ref:: fresh_x != n ==> !(n in singleton_graph)
    lhs_node := fresh_x
    inhale acc(lhs_node.$field$) && lhs_node.$field$ == null
}

method link_$field$(g:Set[Ref], x:Ref, y:Ref)
    requires x in g
    requires y != null ==> y in g
    //requires !(edge($$(g), x, y))
    requires PROTECTED_GRAPH(g,x,$field$)
    ensures PROTECTED_GRAPH(g,x,$field$)
    ensures x.$field$ == y
    ensures y == null ==> $$(g) == old($$(g))
    ensures y != null ==> forall v1:Ref, v2:Ref ::
        { edge(old($$(g)),v1,v2) }
            edge($$(g),v1,v2) <==> edge(old($$(g)),v1,v2) || (v1==x && v2==y)
    ensures y != null ==> forall v1:Ref, v2:Ref ::
        { exists_path($$(g),v1,v2) }
            exists_path($$(g),v1,v2) <==> exists_path(old($$(g)),v1,v2) || (exists_path(old($$(g)),v1,x) && exists_path(old($$(g)),y,v2))


method unlink_$field$(g:Set[Ref], x:Ref)
    requires x in g
    requires PROTECTED_GRAPH(g,x,$field$)
    ensures PROTECTED_GRAPH(g,x,$field$)
    ensures x.$field$ == null
    ensures old(x.$field$) == null ==> $$(g) == old($$(g))
    ensures old(x.$field$) != null ==> forall v1:Ref, v2:Ref ::
        { edge($$(g),v1,v2) }
            edge($$(g),v1,v2) <==> edge(old($$(g)),v1,v2) && !(v1==x && v2==old(x.$field$))
//    ensures old(x.$field$) != null ==> forall v1: Ref, v2:Ref ::
//        { exists_path($$(g),v1, v2)}
//            ( exists_path($$(g), v1, v2)) <==> (v1 == v2) ||
//            ( exists n: Ref :: edge($$(g), v1, n) && exists_path($$(g), n, v2))
//    ensures old(x.$field$) != null ==> (forall v1:Ref, v2:Ref ::
//        { exists_path($$(g),v1,v2) }
//            (v1 != v2) ==> (
//                exists_path($$(g),v1,v2) <==>
//                    exists_path(old($$(g)),v1,v2) && !(exists_path(old($$(g)),v1,x) && exists_path(old($$(g)),old(x.$field$),v2))))

/*TODO for unlink DAGS*/
//    ensures old(x.$field$) != null ==> forall v1:Ref, v2:Ref ::
//        { exists_path($$(g),v1,v2) }
//            //v1 != v2 ==>
//            ( exists_path($$(g),v1,v2) <==> (v1==v2) || (v1!=v2 && (
//                ( exists n:Ref :: exists_path(old($$(g)),v1,n) && exists_path(old($$(g)),n,v2) && ( !exists_path(old($$(g)),n,x) && !exists_path(old($$(g)),x,n) || !exists_path(old($$(g)),n,old(x.$field$)) && !exists_path(old($$(g)),old(x.$field$),n) ) )
//                ||
//                ( exists n:Ref :: n != x && n != old(x.$field$) && exists_path(old($$(g)),x,n) && exists_path(old($$(g)),n,old(x.$field$)) )
//                ||
//                ( exists u:Ref, v:Ref :: (u != x || v != old(x.$field$)) && edge(old($$(g)),u,v) && exists_path(old($$(g)),v1,u) && exists_path(old($$(g)),u,x) && exists_path(old($$(g)),old(x.$field$),v) && exists_path(old($$(g)),v,v2) )
//            ) ) )

function apply_no_exit_closed(EG: Set[Edge], g1: Set[Ref], g2: Set[Ref]): Bool
    requires PROTECTED_GRAPH(g1) && CLOSED(g1)
    requires PROTECTED_GRAPH(g2)
    ensures forall v1: Ref, v2:Ref ::
    {exists_path(EG,v1,v2)}
        v1 in g1 && v2 in g2 ==> !exists_path(EG, v1, v2)

function GRAPH_decl(g: Set[Ref]): Bool

function CLOSED_GRAPH_decl(g: Set[Ref]): Bool

function ZOPG_decl(g: Set[Ref]): Bool

function CLOSED_ZOPG_decl(g: Set[Ref]): Bool

function DAG_decl(g: Set[Ref]): Bool

function CLOSED_DAG_decl(g: Set[Ref]): Bool

function FOREST_decl(g:Set[Ref]): Bool

function CLOSED_FOREST_decl(g: Set[Ref]): Bool

method update_$field$(g:Set[Ref], x:Ref, y:Ref)

