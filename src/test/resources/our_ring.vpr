
/*
define UNSHARED_CONNECTED(g)
    ( forall v1:Ref, v2:Ref, v:Ref :: { v in g, v1.next, v2.next } v1 in g && v2 in g && v in g ==> ( v1.next == v && v2.next == v ==> v1 == v2 ) )
    && ( forall v:Ref :: { v.next } v in g ==> ( v == v.next <==> g == Set(v) ) )

define RING(nodes)
    !(null in nodes)
    && ( forall n:Ref :: {n.next} n in nodes ==> acc(n.next) )
    && ( forall n:Ref ::
        {n.next in nodes}
        {n in nodes, n.next}
            n in nodes ==> n.next in nodes )








*/




































field next:Node
field val:Int


method ringInsert(g:Graph[ZOPG, Closed], start:Node, x:Int)
    returns (new_g:Graph[ZOPG, Closed], new_node2:Node, new_start:Node)

    //requires RING(g)
    requires FUNCTIONAL(g) && UNSHARED(g) && (forall u: Ref, v: Ref :: {exists_path($$(g), v, u)}{exists_path($$(g), u, v)} u in g && v in g ==> exists_path($$(g), u, v) || exists_path($$(g), v, u)) //&& CONNECTED(g)
    requires forall n: Ref :: {n.next} n in g ==> n.next in g && n.next != null
    requires start in g

    requires forall n:Node, m:Node ::
        { EXISTS_PATH(g,n,m) }
            n in g && m in g ==> EXISTS_PATH(g,n,m) && EXISTS_PATH(g,m,n)

    requires forall n:Ref :: { n.val } n in g ==> acc(n.val)

   // ensures RING(new_g)
    ensures UNSHARED(new_g)
    ensures new_start in new_g
    ensures !(new_node2 in g) && new_node2 in new_g

    // ensures forall n:Ref, m:Ref ::
    //     { exists_path($$(new_g),n,m) }
    //         n in new_g && m in new_g
    //             ==> exists_path($$(new_g),n,m) && exists_path($$(new_g),m,n)
{
    //var n:Node := new_node2()
    //new_g, 
    new_node2 := new_node()//create_node(g/*, x*/)
    inhale acc(new_node2.val, write)
    new_g := g union Set(new_node2)//UNIVERSE

    var node:Node := start

    while ( !( node.val <= x && x < node.next.val
               || node.next == start && ( node.val <= x || x < start.val ) ) )

        //invariant RING(g)
        invariant FUNCTIONAL(g) && UNSHARED(g) && (forall u: Ref, v: Ref :: {exists_path($$(g), v, u)}{exists_path($$(g), u, v)} u in g && v in g ==> exists_path($$(g), u, v) || exists_path($$(g), v, u)) //&& CONNECTED(g)
        invariant forall n: Ref :: {n.next} n in g ==> n.next in g && n.next != null
        invariant forall n: Ref :: {n.val} n in new_g ==> acc(n.val, write)
        invariant node in g

        invariant forall n:Node, m:Node ::
            { EXISTS_PATH(g,n,m) }
                n in g && m in g ==> EXISTS_PATH(g,n,m) && EXISTS_PATH(g,m,n)
    {
        node := node.next
    }

    if ( node.next == start && x < start.val ) {
        new_start := new_node2
    } else {
        new_start := start
    }
}
    // new_node2.next := node.next
    // node.next := new_node2
