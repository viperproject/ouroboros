domain Edge {
  
  function edge_pred(e: Edge): Ref
  
  function edge_succ(e: Edge): Ref
  
  function create_edge(p: Ref, s: Ref): Edge
  
  function create_edge_(p: Ref, s: Ref): Edge
  
  axiom edge_injectivity {
    (forall p: Ref, s: Ref :: { create_edge(p, s) } edge_pred(create_edge(p, s)) == p && edge_succ(create_edge(p, s)) == s)
  }
}

domain TrClo {
  
  function exists_path(EG: Set[Edge], start: Ref, end: Ref): Bool
  
  function exists_path_(EG: Set[Edge], start: Ref, end: Ref): Bool
  
  function exists_spath(EG: Set[Edge], from: Set[Ref], to: Ref): Bool
  
  function apply_noExit(EG: Set[Edge], U: Set[Ref], M: Set[Ref]): Bool
  
  function inst_uReach(EG: Set[Edge], x_0: Ref): Set[Ref]
  
  function inst_uReach_rev(EG: Set[Edge], x_0: Ref): Set[Ref]
  
  function acyclic_graph(EG: Set[Edge]): Bool
  
  function unshared_graph(EG: Set[Edge]): Bool
  
  function func_graph(EG: Set[Edge]): Bool
  
  function edge(EG: Set[Edge], p: Ref, s: Ref): Bool
  
  function edge_(EG: Set[Edge], p: Ref, s: Ref): Bool
  
  function succs(EG: Set[Edge], pred: Ref): Set[Ref]
  
  axiom ax_Succs {
    (forall EG: Set[Edge], pred: Ref, succ: Ref :: { (succ in succs(EG, pred)) } (succ in succs(EG, pred)) == edge_(EG, pred, succ))
  }
  
  axiom ax_EdgeSynonim {
    (forall EG: Set[Edge], p: Ref, s: Ref :: { edge(EG, p, s) } edge(EG, p, s) == edge_(EG, p, s))
  }
  
  axiom ax_Edge {
    (forall EG: Set[Edge], p: Ref, s: Ref :: { (create_edge(p, s) in EG) } { edge(EG, p, s) } edge_(EG, p, s) == (create_edge(p, s) in EG))
  }
  
  axiom ax_NoExit {
    (forall EG: Set[Edge], U: Set[Ref], M: Set[Ref] :: { apply_noExit(EG, U, M) } apply_noExit(EG, U, M) ==> (forall u_0: Ref, v_0: Ref :: { edge(EG, u_0, v_0) } { (u_0 in M),(v_0 in M) } (u_0 in M) && ((v_0 in U) && !((v_0 in M))) ==> !edge(EG, u_0, v_0)) ==> (forall u_0: Ref, v_0: Ref :: { exists_path(EG, u_0, v_0) } { (u_0 in M),(v_0 in M) } (u_0 in M) && ((v_0 in U) && !((v_0 in M))) ==> !exists_path(EG, u_0, v_0)))
  }
  
  axiom ax_instantiation_uReach {
    (forall EG: Set[Edge], x_0: Ref, v_0: Ref :: { (v_0 in inst_uReach(EG, x_0)) } { exists_path(EG, x_0, v_0) } (v_0 in inst_uReach(EG, x_0)) == exists_path(EG, x_0, v_0))
  }
  
  axiom ax_instantiation_uReach_rev {
    (forall EG: Set[Edge], u_0: Ref, y: Ref :: { (u_0 in inst_uReach_rev(EG, y)) } { exists_path(EG, u_0, y) } (u_0 in inst_uReach_rev(EG, y)) == exists_path(EG, u_0, y))
  }
  
  axiom ax_Alias {
    (forall EG: Set[Edge], start: Ref, end: Ref :: { exists_path(EG, start, end) } exists_path(EG, start, end) == exists_path_(EG, start, end))
  }
  
  axiom ax_ExistsPath {
    (forall EG: Set[Edge], start: Ref, end: Ref :: { exists_path(EG, start, end) } { edge(EG, start, end) } exists_path_(EG, start, end) == (start == end || (exists w: Ref :: edge(EG, start, w) && exists_path_(EG, w, end))))
  }
  
  axiom ax_ExistsPathTrans {
    (forall EG: Set[Edge], u_0: Ref, v_0: Ref, w: Ref :: { exists_path(EG, u_0, w),exists_path(EG, w, v_0) } exists_path_(EG, u_0, w) && exists_path_(EG, w, v_0) ==> exists_path_(EG, u_0, v_0))
  }
  
  axiom ax_AcyclicGraph {
    (forall EG: Set[Edge] :: { acyclic_graph(EG) } acyclic_graph(EG) == (forall v1: Ref, v2: Ref :: { edge(EG, v1, v2) } { exists_path(EG, v2, v1) } !edge(EG, v1, v2) || !exists_path(EG, v2, v1)))
  }
  
  axiom ax_UnsharedGraph {
    (forall EG: Set[Edge] :: { unshared_graph(EG) } unshared_graph(EG) == (forall v1: Ref, v2: Ref, v_0: Ref :: { edge(EG, v1, v_0),edge(EG, v2, v_0) } edge(EG, v1, v_0) && edge(EG, v2, v_0) ==> v1 == v2))
  }
  
  axiom ax_FuncGraph {
    (forall EG: Set[Edge] :: { func_graph(EG) } func_graph(EG) == (forall v1: Ref, v2: Ref, v_0: Ref :: { edge(EG, v_0, v1),edge(EG, v_0, v2) } edge(EG, v_0, v1) && edge(EG, v_0, v2) ==> v1 == v2))
  }
  
  axiom ax_ExistsSetPath {
    (forall EG: Set[Edge], from: Set[Ref], to: Ref :: { exists_spath(EG, from, to) } exists_spath(EG, from, to) == (exists f: Ref :: (f in from) && exists_path(EG, f, to)))
  }
}

domain Node {
  
  
}

domain Graph {
  
  
}

domain List {
  
  
}

domain TriggerWisdoms {
  
  function __learn_trigger__(bla: Bool): Bool
  
  function __trigger_ref__(r_0: Ref): Bool
}

domain ZeroOnePathGraphTCs {
  
  function DEP(EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref, v_0: Ref): Bool
  
  function DEP_(EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref, v_0: Ref): Bool
  
  axiom ax_DEP_alias {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP(EG, x_0, y, u_0, v_0) } DEP(EG, x_0, y, u_0, v_0) == DEP_(EG, x_0, y, u_0, v_0))
  }
  
  axiom ax_DEP_0_2 {
    (forall EG: Set[Edge], x_0: Ref, y: Ref :: { DEP(EG, x_0, y, x_0, y) } { edge(EG, x_0, y) } edge(EG, x_0, y) == DEP_(EG, x_0, y, x_0, y))
  }
  
  axiom ax_HeadTriangleImposable {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, v_0: Ref :: { DEP(EG, x_0, y, x_0, v_0) } { exists_path_(EG, x_0, y),exists_path(EG, v_0, y) } { edge(EG, x_0, v_0),exists_path_(EG, v_0, y) } exists_path_(EG, x_0, y) && (edge(EG, x_0, v_0) && exists_path_(EG, v_0, y)) ==> DEP_(EG, x_0, y, x_0, v_0))
  }
  
  axiom ax_TailTriangleImposable {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref :: { DEP(EG, x_0, y, u_0, y) } { exists_path_(EG, x_0, y),exists_path(EG, x_0, u_0) } { edge(EG, u_0, y),exists_path_(EG, x_0, u_0) } exists_path_(EG, x_0, y) && (exists_path_(EG, x_0, u_0) && edge(EG, u_0, y)) ==> DEP_(EG, x_0, y, u_0, y))
  }
  
  axiom ax_NoEdgeNoDEP {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP(EG, x_0, y, u_0, v_0) } !edge(EG, u_0, v_0) ==> !DEP_(EG, x_0, y, u_0, v_0))
  }
  
  axiom ax_DEP_trigger_magic {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP(EG, x_0, y, u_0, v_0) } DEP(EG, x_0, y, u_0, v_0) ==> exists_path(EG, x_0, y) && edge(EG, u_0, v_0))
  }
  
  axiom ax_DEP_6_head {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, n: Ref :: { DEP(EG, y, n, x_0, y) } n != y ==> !DEP_(EG, y, n, x_0, y))
  }
  
  axiom ax_DEP_6_tail {
    (forall EG: Set[Edge], x_0: Ref, y: Ref, n: Ref :: { DEP(EG, n, x_0, x_0, y) } n != x_0 ==> !DEP_(EG, n, x_0, x_0, y))
  }
  
  axiom ax_DEP_7 {
    (forall EG: Set[Edge], nu: Ref, n: Ref, mu: Ref, sigma: Ref :: { DEP(EG, nu, n, mu, sigma) } nu != n && (n != sigma && (nu != mu && (edge(EG, nu, sigma) && edge(EG, mu, sigma)))) ==> !DEP_(EG, nu, n, mu, sigma))
  }
}

field next: Ref

function $$(nodes: Set[Ref]): Set[Edge]
  requires (forall n: Ref :: { n.next } (n in nodes) ==> acc(n.next, 1 / 2))
  ensures (forall p: Ref, s: Ref :: { create_edge(p, s) } ((p in nodes) && (s in nodes) && p.next == s && p != s) == (create_edge(p, s) in result))
  ensures (forall p: Ref, s: Ref :: { (p in nodes),(s in nodes),exists_path(result, p, s) } (p in nodes) && exists_path(result, p, s) ==> (s in nodes))
  ensures (forall p: Ref, s: Ref :: { (p in nodes),(s in nodes),exists_path(result, p, s) } (s in nodes) && exists_path(result, p, s) ==> (p in nodes)) 


function DISJOINT(g1_0: Set[Ref], g2: Set[Ref]): Bool 
{
  (forall n: Ref :: { (n in g1_0),(n in g2) } (n in g1_0) ==> !((n in g2))) && (forall n: Ref :: { (n in g1_0),(n in g2) } (n in g2) ==> !((n in g1_0)))
}

function NoNullInGraph(g0_0: Set[Ref]): Bool 
{
  !((null in g0_0))
}

function CLOSED(g: Set[Ref]): Bool
  requires (forall n: Ref :: { n.next } (n in g) ==> acc(n.next, 1 / 2)) 
{
  (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g))
}

function apply_TCFraming(g0_0: Set[Ref], g1_0: Set[Ref]): Bool
  requires (forall n: Ref :: { n.next } (n in g0_0) ==> acc(n.next, 1 / 2))
  requires (forall n: Ref :: { n.next } (n in g1_0) ==> acc(n.next, 1 / 2))
  requires (forall n: Ref :: { (n in g0_0),(n in g1_0) } (n in g0_0) ==> !((n in g1_0)))
  requires (forall n: Ref :: { (n in g0_0),(n in g1_0) } (n in g1_0) ==> !((n in g0_0)))
  ensures g0_0 union g1_0 == g1_0 union g0_0
  ensures (forall u_0: Ref, v_0: Ref :: { exists_path($$(g0_0), u_0, v_0) } { exists_path($$(g0_0 union g1_0), u_0, v_0) } (u_0 in g0_0) && ((v_0 in g0_0) && exists_path($$(g0_0), u_0, v_0)) ==> exists_path($$(g0_0 union g1_0), u_0, v_0))
  ensures (forall u_0: Ref, v_0: Ref :: { exists_path($$(g1_0), u_0, v_0) } { exists_path($$(g1_0 union g0_0), u_0, v_0) } (u_0 in g1_0) && ((v_0 in g1_0) && exists_path($$(g1_0), u_0, v_0)) ==> exists_path($$(g1_0 union g0_0), u_0, v_0))
  ensures (forall u_0: Ref, v_0: Ref :: { exists_path($$(g0_0), u_0, v_0) } { exists_path($$(g0_0 union g1_0), u_0, v_0) } (u_0 in g0_0) && ((v_0 in g0_0) && !exists_path($$(g0_0 union g1_0), u_0, v_0)) ==> !exists_path($$(g0_0), u_0, v_0))
  ensures (forall u_0: Ref, v_0: Ref :: { exists_path($$(g1_0), u_0, v_0) } { exists_path($$(g1_0 union g0_0), u_0, v_0) } (u_0 in g1_0) && ((v_0 in g1_0) && !exists_path($$(g1_0 union g0_0), u_0, v_0)) ==> !exists_path($$(g1_0), u_0, v_0)) 


function update_DAG_invariant(g: Set[Ref], x_0: Ref, y: Ref): Bool
  requires !((null in g)) && (forall n: Ref :: { n.next } (n in g) ==> acc(n.next, 1 / 2)) 
{
  !exists_path($$(g), y, x_0)
}

function apply_no_exit_closed(EG: Set[Edge], g1_0: Set[Ref], g2: Set[Ref]): Bool
  requires !((null in g1_0)) && (forall n: Ref :: { n.next } (n in g1_0) ==> acc(n.next, 1 / 2)) && CLOSED(g1_0)
  requires !((null in g2)) && (forall n: Ref :: { n.next } (n in g2) ==> acc(n.next, 1 / 2))
  ensures (forall v1: Ref, v2: Ref :: { exists_path(EG, v1, v2) } (v1 in g1_0) && (v2 in g2) ==> !exists_path(EG, v1, v2)) 


function GRAPH_decl(g: Set[Ref]): Bool 


function CLOSED_GRAPH_decl(g: Set[Ref]): Bool 


function ZOPG_decl(g: Set[Ref]): Bool 


function CLOSED_ZOPG_decl(g: Set[Ref]): Bool 


function DAG_decl(g: Set[Ref]): Bool 


function CLOSED_DAG_decl(g: Set[Ref]): Bool 


function FOREST_decl(g: Set[Ref]): Bool 


function CLOSED_FOREST_decl(g: Set[Ref]): Bool 


function update_ZOPG_invariant(g: Set[Ref], from: Ref, to: Ref): Bool
  requires !((null in g)) && (forall n: Ref :: { n.next } (n in g) ==> acc(n.next, 1 / 2)) 
{
  func_graph($$(g)) || (unshared_graph($$(g)) || (forall u_0: Ref, v_0: Ref :: { exists_path($$(g), u_0, from),exists_path($$(g), to, v_0) } (u_0 in g) && ((v_0 in g) && (u_0 != v_0 && exists_path($$(g), u_0, v_0))) ==> !exists_path($$(g), u_0, from) || !exists_path($$(g), to, v_0)))
}

method new_node() returns (node: Ref)


method create_node(u_0: Set[Ref]) returns (node: Ref)
{
  var UNIVERSE: Set[Ref]
  var lhs_node: Ref
  var fresh_x: Ref
  var singleton_graph: Set[Ref]
  UNIVERSE := Set[Ref]()
  inhale !((fresh_x in u_0))
  inhale (fresh_x in singleton_graph) && (forall n: Ref :: fresh_x != n ==> !((n in singleton_graph)))
  lhs_node := fresh_x
  inhale acc(lhs_node.next, write) && lhs_node.next == null
}

method link_next(g: Set[Ref], x_0: Ref, y: Ref)
  requires (x_0 in g)
  requires y != null ==> (y in g)
  requires !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures x_0.next == y
  ensures y == null ==> $$(g) == old($$(g))
  ensures y != null ==> (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x_0 && v2 == y))
  ensures y != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x_0) && exists_path(old($$(g)), y, v2)))


method unlink_next(g: Set[Ref], x_0: Ref)
  requires (x_0 in g)
  requires !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures x_0.next == null
  ensures old(x_0.next) == null ==> $$(g) == old($$(g))
  ensures old(x_0.next) != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x_0 && v2 == old(x_0.next))))


method unlink_DAG_next(g: Set[Ref], x_0: Ref)
  requires (x_0 in g)
  requires !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures x_0.next == null
  ensures old(x_0.next) == null ==> $$(g) == old($$(g))
  ensures old(x_0.next) != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == x_0 && v2 == old(x_0.next))))
  ensures old(x_0.next) != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (v1 == v2 || ((exists n: Ref :: exists_path(old($$(g)), v1, n) && (exists_path(old($$(g)), n, v2) && (!exists_path(old($$(g)), n, x_0) && !exists_path(old($$(g)), x_0, n) || !exists_path(old($$(g)), n, old(x_0.next)) && !exists_path(old($$(g)), old(x_0.next), n)))) || ((exists n: Ref :: n != x_0 && (n != old(x_0.next) && (exists_path(old($$(g)), x_0, n) && exists_path(old($$(g)), n, old(x_0.next))))) || (exists u_0: Ref, v_0: Ref :: (u_0 != x_0 || v_0 != old(x_0.next)) && (edge(old($$(g)), u_0, v_0) && (exists_path(old($$(g)), v1, u_0) && (exists_path(old($$(g)), u_0, x_0) && (exists_path(old($$(g)), old(x_0.next), v_0) && exists_path(old($$(g)), v_0, v2))))))))))


method link_DAG_next(g: Set[Ref], x_0: Ref, y: Ref)
  requires (x_0 in g)
  requires y != null ==> (y in g)
  requires !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures !((null in g)) && ((x_0 in g) && (acc(x_0.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != x_0 ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures x_0.next == y
  ensures y == null ==> $$(g) == old($$(g))
  ensures y != null ==> (forall v1: Ref, v2: Ref :: { edge(old($$(g)), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == x_0 && v2 == y))
  ensures y != null ==> (forall v1: Ref, v2: Ref :: { exists_path($$(g), v1, v2) } exists_path($$(g), v1, v2) == (exists_path(old($$(g)), v1, v2) || exists_path(old($$(g)), v1, x_0) && exists_path(old($$(g)), y, v2)))
  ensures acyclic_graph($$(g))


method update_next(g: Set[Ref], x_0: Ref, y: Ref)


method update_DAG_next(g: Set[Ref], x_0: Ref, y: Ref)


method unlink_ZOPG_next(g: Set[Ref], node: Ref)
  requires (node in g)
  requires !((null in g)) && ((node in g) && (acc(node.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != node ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures !((null in g)) && ((node in g) && (acc(node.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != node ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures node.next == null
  ensures old(node.next) == null ==> $$(g) == old($$(g))
  ensures old(node.next) != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } { exists_path($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) && !(v1 == node && v2 == old(node.next))))
  ensures old(node.next) != null ==> (forall x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP($$(g), x_0, y, u_0, v_0) } { DEP(old($$(g)), x_0, y, u_0, v_0) } DEP(old($$(g)), x_0, y, u_0, v_0) && !DEP(old($$(g)), x_0, y, node, old(node.next)) ==> DEP($$(g), x_0, y, u_0, v_0))


method link_ZOPG_next(g: Set[Ref], from: Ref, to: Ref)
  requires (from in g)
  requires !((null in g)) && ((from in g) && (acc(from.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != from ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g))))) && from.next == null
  ensures !((null in g)) && ((from in g) && (acc(from.next, write) && ((forall n: Ref :: { n.next } (n in g) && n != from ==> acc(n.next, 1 / 2)) && (forall n: Ref :: { (n.next in g) } { (n in g),n.next } (n in g) && n.next != null ==> (n.next in g)))))
  ensures from.next == to
  ensures to == null ==> $$(g) == old($$(g))
  ensures to != null ==> (forall v1: Ref, v2: Ref :: { edge($$(g), v1, v2) } { exists_path($$(g), v1, v2) } edge($$(g), v1, v2) == (edge(old($$(g)), v1, v2) || v1 == from && v2 == to))
  ensures to != null ==> (forall x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP($$(g), x_0, y, u_0, v_0) } { DEP(old($$(g)), x_0, y, u_0, v_0) } from != to && (u_0 != v_0 && x_0 != y) ==> DEP(old($$(g)), x_0, y, u_0, v_0) || (x_0 == from && (u_0 == from && (y == to && v_0 == to)) || ((exists w: Ref, z: Ref :: (forall u_: Ref, v_: Ref :: { DEP(old($$(g)), x_0, y, u_, v_) } !DEP(old($$(g)), x_0, y, u_, v_)) && ((DEP(old($$(g)), x_0, from, u_0, v_0) && x_0 != from || x_0 == u_0 && (u_0 == from && v_0 == to)) && (DEP(old($$(g)), to, y, w, z) && to != y || from == w && (to == z && z == y)))) || ((exists U: Ref, V: Ref :: (forall u_$0: Ref, v_$0: Ref :: { DEP(old($$(g)), x_0, y, u_$0, v_$0) } !DEP(old($$(g)), x_0, y, u_$0, v_$0)) && ((DEP(old($$(g)), x_0, from, U, V) && x_0 != from || x_0 == U && (U == from && V == to)) && (DEP(old($$(g)), to, y, u_0, v_0) && to != y || from == u_0 && (to == v_0 && v_0 == y)))) || u_0 == from && (v_0 == to && (exists U: Ref, V: Ref, w: Ref, z: Ref :: (forall u_$1: Ref, v_$1: Ref :: { DEP(old($$(g)), x_0, y, u_$1, v_$1) } !DEP(old($$(g)), x_0, y, u_$1, v_$1)) && ((DEP(old($$(g)), x_0, from, U, V) && x_0 != from || x_0 == U && (U == from && V == to)) && (DEP(old($$(g)), to, y, w, z) && to != y || from == w && (to == z && z == y)))))))) ==> DEP($$(g), x_0, y, u_0, v_0))
  ensures to != null ==> (forall x_0: Ref, y: Ref, u_0: Ref, v_0: Ref :: { DEP($$(g), x_0, y, u_0, v_0) } { DEP(old($$(g)), x_0, y, u_0, v_0) } DEP($$(g), x_0, y, u_0, v_0) && !DEP($$(g), x_0, y, from, to) ==> DEP(old($$(g)), x_0, y, u_0, v_0))
  ensures to != null ==> (forall n: Ref :: { exists_path($$(g), to, n) } { exists_path($$(g), from, n) } (n in g) && n != from ==> __learn_trigger__(DEP($$(g), from, n, from, from.next)))
  ensures to != null ==> (forall n: Ref :: { exists_path($$(g), to, n) } { exists_path($$(g), from, n) } (n in g) && n != to ==> __learn_trigger__(DEP($$(g), to, n, to, to.next)))
  ensures to != null ==> (forall n: Ref :: { exists_path($$(g), n, to) } { exists_path($$(g), n, from) } (n in g) && n != from ==> __learn_trigger__(DEP($$(g), n, from, n, n.next)))
  ensures to != null ==> (forall n: Ref :: { DEP($$(g), to, n, to, to.next) } { DEP($$(g), from, n, from, from.next) } (n in g) ==> __learn_trigger__(exists_path($$(g), to, n)) && __learn_trigger__(exists_path(old($$(g)), to, n)))


method update_ZOPG_next(g: Set[Ref], x_0: Ref, y: Ref)


method join(g0: Set[Ref], g1: Set[Ref], x0: Ref, x1: Ref) returns (x: Ref, last: Ref)
  requires DISJOINT(g0, g1)
  requires NoNullInGraph(g0) && (forall n: Ref :: { n.next } (n in g0) ==> acc(n.next, write))
  requires NoNullInGraph(g1) && ((forall n: Ref :: { n.next } (n in g1) ==> acc(n.next, write)) && CLOSED(g1))
  requires CLOSED(g0 union g1)
  requires CLOSED(g0)
  requires (x0 in g0)
  requires (x1 in g1)
  requires acyclic_graph($$(g0)) && (func_graph($$(g0)) && unshared_graph($$(g0)))
  requires acyclic_graph($$(g1)) && (func_graph($$(g1)) && unshared_graph($$(g1)))
  requires (forall n: Ref :: { exists_path($$(g0), x0, n) } (n in g0) ==> exists_path($$(g0), x0, n))
  requires (forall n: Ref :: { exists_path($$(g1), x1, n) } (n in g1) ==> exists_path($$(g1), x1, n))
  ensures (forall n: Ref :: { n.next } (n in g0 union g1) ==> acc(n.next, write))
  ensures NoNullInGraph(g0)
  ensures NoNullInGraph(g1) && CLOSED(g1)
  ensures CLOSED(g0 union g1)
  ensures (forall u: Ref :: exists_path($$(g0 union g1), x, u) == (old(exists_path($$(g0), x0, u)) || old(exists_path($$(g1), x1, u))))
  ensures (forall u: Ref, v: Ref :: edge($$(g0 union g1), u, v) == (old(edge($$(g0), u, v)) || (old(edge($$(g1), u, v)) || u == last && v == x1)))
  ensures acyclic_graph($$(g0 union g1)) && (func_graph($$(g0 union g1)) && unshared_graph($$(g0 union g1)))
{
  var UNIVERSE: Set[Ref]
  UNIVERSE := g0 union g1
  
  // Apply TC Framing for input graphs g0 and g1 
inhale apply_TCFraming(g0, g1)
  
  // Assume there are no paths from closed Graph g1 to disjoint Graph g0 
inhale apply_no_exit_closed($$(g0 union g1), g1, g0)
  last := x0
  if (last == null) {
    x := x1
  } else {
    while (last.next != null)
      invariant g0 subset UNIVERSE
      invariant g1 subset UNIVERSE
      invariant NoNullInGraph(UNIVERSE)
      invariant (forall n: Ref :: { n.next } (n in UNIVERSE) ==> acc(n.next, write))
      invariant CLOSED(UNIVERSE)
      invariant CLOSED(g1)
      invariant CLOSED(g0)
      invariant (x0 in g0)
      invariant (x1 in g1)
      invariant (forall r: Ref :: { (r in g0),(r in g1) } (r in g0) ==> !((r in g1))) && (forall r: Ref :: { (r in g0),(r in g1) } (r in g1) ==> !((r in g0)))
      invariant acyclic_graph($$(g0)) && (func_graph($$(g0)) && unshared_graph($$(g0)))
      invariant acyclic_graph($$(g1)) && (func_graph($$(g1)) && unshared_graph($$(g1)))
      invariant (forall n: Ref :: { exists_path($$(g0), x0, n) } (n in g0) ==> exists_path($$(g0), x0, n))
      invariant (forall n: Ref :: { exists_path($$(g1), x1, n) } (n in g1) ==> exists_path($$(g1), x1, n))
      invariant (last in g0)
      invariant $$(g0) == old($$(g0))
      invariant $$(g1) == old($$(g1)) 
    {
      last := last.next
    }
    unlink_next(UNIVERSE, last)
    link_next(UNIVERSE, last, x1)
  }
  x := x0
}