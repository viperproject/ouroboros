domain Edge {
  
  function edge_pred(e: Edge): Ref
  
  function edge_succ(e: Edge): Ref
  
  function create_edge(p: Ref, s: Ref): Edge
  
  function create_edge_(p: Ref, s: Ref): Edge
  
  axiom edge_injectivity {
    (forall p: Ref, s: Ref :: { create_edge(p, s) } edge_pred(create_edge(p, s)) == p && edge_succ(create_edge(p, s)) == s)
  }
}

domain TrClo {
  
  function exists_path(EG: Set[Edge], start: Ref, end: Ref): Bool
  
  function exists_path_(EG: Set[Edge], start: Ref, end: Ref): Bool
  
  function exists_spath(EG: Set[Edge], from: Set[Ref], to: Ref): Bool
  
  function apply_noExit(EG: Set[Edge], U: Set[Ref], M: Set[Ref]): Bool
  
  function inst_uReach(EG: Set[Edge], x: Ref): Set[Ref]
  
  function inst_uReach_rev(EG: Set[Edge], x: Ref): Set[Ref]
  
  function acyclic_graph(EG: Set[Edge]): Bool
  
  function unshared_graph(EG: Set[Edge]): Bool
  
  function func_graph(EG: Set[Edge]): Bool
  
  function edge(EG: Set[Edge], p: Ref, s: Ref): Bool
  
  function edge_(EG: Set[Edge], p: Ref, s: Ref): Bool
  
  function succs(EG: Set[Edge], pred: Ref): Set[Ref]
  
  axiom ax_Succs {
    (forall EG: Set[Edge], pred: Ref, succ: Ref :: { (succ in succs(EG, pred)) } (succ in succs(EG, pred)) == edge_(EG, pred, succ))
  }
  
  axiom ax_EdgeSynonim {
    (forall EG: Set[Edge], p: Ref, s: Ref :: { edge(EG, p, s) } edge(EG, p, s) == edge_(EG, p, s))
  }
  
  axiom ax_Edge {
    (forall EG: Set[Edge], p: Ref, s: Ref :: { (create_edge(p, s) in EG) } { edge(EG, p, s) } edge_(EG, p, s) == (create_edge(p, s) in EG))
  }
  
  axiom ax_NoExit {
    (forall EG: Set[Edge], U: Set[Ref], M: Set[Ref] :: { apply_noExit(EG, U, M) } apply_noExit(EG, U, M) ==> (forall u: Ref, v: Ref :: { edge(EG, u, v) } { (u in M),(v in M) } (u in M) && ((v in U) && !((v in M))) ==> !edge(EG, u, v)) ==> (forall u: Ref, v: Ref :: { exists_path(EG, u, v) } { (u in M),(v in M) } (u in M) && ((v in U) && !((v in M))) ==> !exists_path(EG, u, v)))
  }
  
  axiom ax_instantiation_uReach {
    (forall EG: Set[Edge], x: Ref, v: Ref :: { (v in inst_uReach(EG, x)) } { exists_path(EG, x, v) } (v in inst_uReach(EG, x)) == exists_path(EG, x, v))
  }
  
  axiom ax_instantiation_uReach_rev {
    (forall EG: Set[Edge], u: Ref, y: Ref :: { (u in inst_uReach_rev(EG, y)) } { exists_path(EG, u, y) } (u in inst_uReach_rev(EG, y)) == exists_path(EG, u, y))
  }
  
  axiom ax_Alias {
    (forall EG: Set[Edge], start: Ref, end: Ref :: { exists_path(EG, start, end) } exists_path(EG, start, end) == exists_path_(EG, start, end))
  }
  
  axiom ax_ExistsPath {
    (forall EG: Set[Edge], start: Ref, end: Ref :: { exists_path(EG, start, end) } { edge(EG, start, end) } exists_path_(EG, start, end) == (start == end || (exists w: Ref :: edge_(EG, start, w) && exists_path_(EG, w, end))))
  }
  
  axiom ax_ExistsPathTrans {
    (forall EG: Set[Edge], u: Ref, v: Ref, w: Ref :: { exists_path(EG, u, w),exists_path(EG, w, v) } exists_path_(EG, u, w) && exists_path_(EG, w, v) ==> exists_path_(EG, u, v))
  }
  
  axiom ax_AcyclicGraph {
    (forall EG: Set[Edge] :: { acyclic_graph(EG) } acyclic_graph(EG) == (forall v1: Ref, v2: Ref :: { edge(EG, v1, v2) } { exists_path(EG, v2, v1) } !edge(EG, v1, v2) || !exists_path(EG, v2, v1)))
  }
  
  axiom ax_UnsharedGraph {
    (forall EG: Set[Edge] :: { unshared_graph(EG) } unshared_graph(EG) == (forall v1: Ref, v2: Ref, v: Ref :: { edge(EG, v1, v),edge(EG, v2, v) } edge(EG, v1, v) && edge(EG, v2, v) ==> v1 == v2))
  }
  
  axiom ax_FuncGraph {
    (forall EG: Set[Edge] :: { func_graph(EG) } func_graph(EG) == (forall v1: Ref, v2: Ref, v: Ref :: { edge(EG, v, v1),edge(EG, v, v2) } edge(EG, v, v1) && edge(EG, v, v2) ==> v1 == v2))
  }
  
  axiom ax_ExistsSetPath {
    (forall EG: Set[Edge], from: Set[Ref], to: Ref :: { exists_spath(EG, from, to) } exists_spath(EG, from, to) == (exists f: Ref :: (f in from) && exists_path(EG, f, to)))
  }
}

domain Node {
  
  
}

domain Graph {
  
  
}

domain List {
  
  
}

field next: Ref

function $$(nodes: Set[Ref]): Set[Edge]
  requires (forall n: Ref :: { n.next } (n in nodes) ==> acc(n.next, 1 / 2))
  ensures (forall p: Ref, s: Ref :: { create_edge(p, s) } ((p in nodes) && (s in nodes) && p.next == s && p != s) == (create_edge(p, s) in result))
  ensures (forall p: Ref, s: Ref :: { (p in nodes),(s in nodes),exists_path(result, p, s) } (p in nodes) && exists_path(result, p, s) ==> (s in nodes))
  ensures (forall p: Ref, s: Ref :: { (p in nodes),(s in nodes),exists_path(result, p, s) } (s in nodes) && exists_path(result, p, s) ==> (p in nodes)) 


method join(g1: Set[Ref], g2: Set[Ref]) returns (g: Set[Ref])
  requires (forall n: Ref :: { (n in g1),(n in g2) } (n in g1) ==> !((n in g2))) && (forall n: Ref :: { (n in g1),(n in g2) } (n in g2) ==> !((n in g1)))
  requires !((null in g1)) && ((forall n: Ref :: { n.next } (n in g1) ==> acc(n.next, write)) && (forall n: Ref :: { (n.next in g1) } { (n in g1),n.next } (n in g1) && n.next != null ==> (n.next in g1)))
  requires !((null in g2)) && (forall n: Ref :: { n.next } (n in g2) ==> acc(n.next, write))
  requires (forall n: Ref :: { (n.next in g1 union g2) } { (n in g1 union g2),n.next } (n in g1 union g2) && n.next != null ==> (n.next in g1 union g2))
  ensures (forall n: Ref :: { n.next } (n in g union g1 union g2) ==> acc(n.next, write))
  ensures !((null in g))
  ensures !((null in g1)) && (forall n: Ref :: { (n.next in g1) } { (n in g1),n.next } (n in g1) && n.next != null ==> (n.next in g1))
  ensures !((null in g2))
{
  exhale (forall n: Ref :: { (n in g1),(n in g2) } (n in g1) ==> !((n in g2)))
  exhale (forall n: Ref :: { (n in g1),(n in g2) } (n in g2) ==> !((n in g1)))
  inhale g1 union g2 == g2 union g1
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g1), u, v) } { exists_path($$(g1 union g2), u, v) } (u in g1) && ((v in g1) && exists_path($$(g1), u, v)) ==> exists_path($$(g1 union g2), u, v))
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g2), u, v) } { exists_path($$(g2 union g1), u, v) } (u in g2) && ((v in g2) && exists_path($$(g2), u, v)) ==> exists_path($$(g2 union g1), u, v))
  inhale !((null in g)) && (forall n: Ref :: { n.next } (n in g) ==> acc(n.next, write))
  exhale (forall n: Ref :: { (n in g2),(n in g setminus g2) } (n in g2) ==> !((n in g setminus g2)))
  exhale (forall n: Ref :: { (n in g2),(n in g setminus g2) } (n in g setminus g2) ==> !((n in g2)))
  inhale g2 union g setminus g2 == g setminus g2 union g2
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g2), u, v) } { exists_path($$(g2 union g setminus g2), u, v) } (u in g2) && ((v in g2) && exists_path($$(g2), u, v)) ==> exists_path($$(g2 union g setminus g2), u, v))
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g setminus g2), u, v) } { exists_path($$(g setminus g2 union g2), u, v) } (u in g setminus g2) && ((v in g setminus g2) && exists_path($$(g setminus g2), u, v)) ==> exists_path($$(g setminus g2 union g2), u, v))
  exhale (forall n: Ref :: { (n in g1),(n in g setminus g1) } (n in g1) ==> !((n in g setminus g1)))
  exhale (forall n: Ref :: { (n in g1),(n in g setminus g1) } (n in g setminus g1) ==> !((n in g1)))
  inhale g1 union g setminus g1 == g setminus g1 union g1
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g1), u, v) } { exists_path($$(g1 union g setminus g1), u, v) } (u in g1) && ((v in g1) && exists_path($$(g1), u, v)) ==> exists_path($$(g1 union g setminus g1), u, v))
  inhale (forall u: Ref, v: Ref :: { exists_path($$(g setminus g1), u, v) } { exists_path($$(g setminus g1 union g1), u, v) } (u in g setminus g1) && ((v in g setminus g1) && exists_path($$(g setminus g1), u, v)) ==> exists_path($$(g setminus g1 union g1), u, v))
  g := g1 union g2
}